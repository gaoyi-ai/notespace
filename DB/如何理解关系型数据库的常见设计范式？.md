---
title: Kill NF (知乎)
categories:
- DB
- NF
tags:
- zhihu
date: 2021/3/10 20:00:17
updated: 2021/3/12 12:00:17
---

# Kill NF ✨

首先要明白” 范式（NF）” 是什么意思。按照教材中的定义，范式是 “符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为**一张数据表的表结构所符合的某种设计标准的级别**。就像家里装修买建材，最环保的是 E0 级，其次是 E1 级，还有 E2 级等等。数据库范式也分为 1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到 BCNF 就够。符合高一级范式的设计，必定符合低一级范式，例如符合 2NF 的关系模式，必定符合 1NF。

接下来就对每一级范式进行一下解释，首先是**第一范式（1NF）。**

符合 1NF 的关系（你可以理解为数据表。“关系模式”和 “关系” 的区别，类似于面向对象程序设计中”类 “与” 对象 “的区别。” 关系 “是” 关系模式 “的一个实例，你可以把” 关系”理解为一张带数据的表，而 “关系模式” 是这张数据表的表结构。**1NF 的定义为：符合 1NF 的关系中的每个属性都不可再分。表 1** 所示的情况，就不符合 1NF 的要求。

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/24afd11455ac34a280fa83e4e8d75ccc_r.jpg)

表 1

实际上，**1NF 是所有关系型数据库的最基本要求**，你在关系型数据库管理系统（RDBMS），例如 SQL Server，Oracle，MySQL 中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在 RDBMS 中已经存在的数据表，一定是符合 1NF 的。如果我们要在 RDBMS 中表现表中的数据，就得设计为**表 2** 的形式：

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/6b735fb9503b0930e741faa474fed28e_r.jpg)

表 2

但是仅仅符合 1NF 的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如对于**表 3** 中的设计：

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/5b16f655b57a957bfa340d0a996a0eea_r.jpg)

表 3

1.  每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——**数据冗余过大**
2.  假如学校新建了一个系，但是暂时还没有招收任何学生（比如 3 月份就新建了，但要等到 8 月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——**插入异常**  
    注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。  
    注２：**码：关系中的某个属性或者某几个属性的组合，用于区分每个元组**（可以把 “元组” 理解为一张表中的每条记录，也就是每一行）**。**
3.  假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——**删除异常**
4.  假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——**修改异常**。

正因为仅符合 1NF 的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的 “规范化”。

**第二范式（2NF）**在关系理论中的严格定义我这里就不多介绍了（因为涉及到的铺垫比较多），只需要了解 2NF 对 1NF 进行了哪些改进即可。其改进是，**2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖**。接下来对这句话中涉及到的四个概念——**“函数依赖”**、**“码”**、**“非主属性”**、与 **“部分函数依赖”** 进行一下解释。

**函数依赖**  
我们可以这么理解（但并不是特别严格的定义）：**若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y**。也就是说，在数据表中，不存在任意两条记录，它们在 X 属性（或属性组）上的值相同，而在 Y 属性上的值不同。这也就是 “函数依赖” 名字的由来，类似于函数关系 y = f(x)，在 x 的值确定的情况下，y 的值一定是确定的。

例如，对于表 3 中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说**姓名函数依赖于学号**，写作 **学号 → 姓名**。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。表中其他的函数依赖关系还有如：

*   系名 → 系主任
*   学号 → 系主任
*   （学号，课名） → 分数

但以下函数依赖关系则不成立：

*   学号 → 课名
*   学号 → 分数
*   课名 → 系主任
*   （学号，课名） → 姓名

从 “函数依赖” 这个概念展开，还会有三个概念：

**完全函数依赖**

在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X **完全函数依赖**，记作 X F→ Y。（那个 F 应该写在箭头的正上方，没办法打出来……，正确的写法如**图 1**）

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/12513de20079d12b99d946072df7311a_hd.jpg)

图 1

例如：

*   学号 F→ 姓名  
    
*   （学号，课名） F→ 分数 （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）

**部分函数依赖**

假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X P→ Y，如**图 2**。

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/10b52b39b18b8ea9fb17b46babf4d20f_hd.jpg)

图 2

例如：

*   （学号，课名） P→ 姓名

**传递函数依赖**  
假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （感谢

@百达 指出的错误，这里改为：『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提），那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z，如**图 3**。

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/51f8105fbbe92adaa3e343ea2db3bf49_hd.jpg)

图 3

**码**  
设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个 “完全” 不要漏了），那么我们称 K 为**候选码**，简称为**码**。在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为**主码**）

例如：  
对于表 3，**（学号、课名）**这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）

**非主属性**  
包含在任何一个码中的属性成为主属性。

例如：  
对于表 3，主属性就有两个，**学号** 与 **课名**。

终于可以回过来看 2NF 了。首先，我们需要判断，表 3 是否符合 2NF 的要求？根据 2NF 的定义，判断的依据实际上就是看数据表中**是否存在非主属性对于码的部分函数依赖**。若存在，则数据表最高只符合 1NF 的要求，若不存在，则符合 2NF 的要求。判断的方法是：

第一步：找出数据表中所有的**码**。  
第二步：根据第一步所得到的码，找出所有的**主属性**。  
第三步：数据表中，除去所有的主属性，剩下的就都是**非主属性**了。  
第四步：查看是否存在非主属性对码的**部分函数依赖**。

对于表 3，根据前面所说的四步，我们可以这么做：

第一步：

1.  查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。
2.  查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。
3.  ……
4.  查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。

看起来很麻烦是吧，但是这里有一个诀窍，就是假如 A 是码，那么所有包含了 A 的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个 “**完全**函数依赖”）。

**图 4** 表示了表中所有的函数依赖关系：

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/51e2689ac9416a91800e63101bee9db7_r.jpg)

图 4

这一步完成以后，可以得到，表 3 的码只有一个，就是**（学号、课名）**。

第二步：  
主属性有两个：**学号** 与 **课名**

第三步：  
非主属性有四个：**姓名**、**系名**、**系主任**、**分数**

**第四步：**  
对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。  
对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 系**名** 对码**（学号，课名）**的部分函数依赖。  
对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性 对码**（学号，课名）**的部分函数依赖。

所以表 3 存在非主属性对于码的部分函数依赖，最高只符合 1NF 的要求，不符合 2NF 的要求。

为了让表 3 符合 2NF 的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做” 模式分解 “。模式分解的方法不是唯一的，以下是其中一种方法：  
选课（学号，课名，分数）  
学生（学号，姓名，系名，系主任）

我们先来判断以下，**选课**表与**学生**表，是否符合了 2NF 的要求？

对于**选课**表，其码是**（学号，课名）**，主属性是**学号**和**课名**，非主属性是**分数**，**学号**确定，并不能唯一确定**分数**，**课名**确定，也不能唯一确定**分数**，所以不存在非主属性**分数**对于码 **（学号，课名）**的部分函数依赖，所以此表符合 2NF 的要求。

对于**学生**表，其码是**学号，**主属性是**学号**，非主属性是**姓名、系名**和**系主任**，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合 2NF 的要求。

**图 5** 表示了模式分解以后的新的函数依赖关系

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/2f4b4a887f6a61674a49d03d79e3fe17_r.jpg)

图 5

表 4 表示了模式分解以后新的数据

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/44af74509a4e21372ed372be8560539d_r.jpg)

表 4

（这里还涉及到一个如何进行模式分解才是正确的知识点，先不介绍了）

现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？

1.  李小明转系到法律系  
    只需要修改一次李小明对应的系的值即可。——有改进
2.  数据冗余是否减少了？  
    学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进
3.  删除某个系中所有的学生记录  
    该系的信息仍然全部丢失。——无改进
4.  插入一个尚无学生的新系的信息。  
    因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进

所以说，仅仅符合 2NF 的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性**系主任**对于码**学号**的传递函数依赖。为了能进一步解决这些问题，我们还需要将符合 2NF 要求的数据表改进为符合 3NF 的要求。

**第三范式（3NF）** **3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖**。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合 3NF 的要求。

接下来我们看看表 4 中的设计，是否符合 3NF 的要求。

对于**选课**表，主码为（学号，课名），主属性为**学号**和**课名，**非主属性只有一个，为分数，不可能存在传递函数依赖，所以**选课**表的设计，符合 3NF 的要求。

对于**学生**表，主码为**学号**，主属性为**学号**，非主属性为**姓名**、**系名**和**系主任**。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性**系主任**对于码**学号**的传递函数依赖，所以**学生**表的设计，不符合 3NF 的要求。。

为了让数据表设计达到 3NF，我们必须进一步进行模式分解为以下形式：  
选课（学号，课名，分数）  
学生（学号，姓名，系名）  
系（系名，系主任）

对于**选课**表，符合 3NF 的要求，之前已经分析过了。

对于**学生**表，码为**学号**，主属性为**学号**，非主属性为**系名**，不可能存在非主属性对于码的传递函数依赖，所以符合 3NF 的要求。

对于**系**表，码为**系名**，主属性为**系名**，非主属性为**系主任**，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合 3NF 的要求。。

新的函数依赖关系如图 6

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/5b20707ff3d9afb51ef7bfda726c3e34_r.jpg)

图 6

新的数据表如表 5

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/8bca802bcff92a8945bf808d18d7ec62_r.jpg)

表 5

现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？

1.  删除某个系中所有的学生记录  
    该系的信息不会丢失。——有改进
2.  插入一个尚无学生的新系的信息。  
    因为系表与学生表目前是独立的两张表，所以不影响。——有改进
3.  数据冗余更加少了。——有改进

**结论**  
由此可见，符合 3NF 要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到 2NF 或者 1NF，但是作为数据库设计人员，至少应该知道，3NF 的要求是怎样的。

**BCNF 范式**

要了解 BCNF 范式，那么先看这样一个问题：

若：

1.  某公司有若干个仓库；  
    
2.  每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；  
    
3.  一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。  
    

那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？

答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量  
码：（管理员，物品名），（仓库名，物品名）  
主属性：仓库名、管理员、物品名  
非主属性：数量  
∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于 3NF。

基于此关系模式的关系（具体的数据）可能如图所示：

![](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/68d080d437732aad8cfe451b427849d6_r.jpg)

好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：

1.  先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
2.  某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。  
    
3.  如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。  
    

从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ” 好 “ 的设计。

造成此问题的原因：存在着**主属性**对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。

解决办法就是要在 3NF 的基础上消除**主属性**对于码的部分与传递函数依赖。

仓库（仓库名，管理员）  
库存（仓库名，物品名，数量）

这样，之前的插入异常，修改异常与删除异常的问题就被解决了。

问题 1：

Q：就是关于码的定义，如果除 K 之外的所有属性都完全函数依赖于 K 时才能称 K 为码，那么在判断 2NF 时又怎么会存在非主属性对码的部分函数依赖这种情况？

A ：在 “码” 的定义中，除 K 之外的所有属性应该看成是一个集合 U（也就是一个整体），也就是说，只有 K 能够完全函数决定 U 中的每一个属性，那么 K 才是码。如果 K 只是能够完全函数决定 U 中的一部分属性，而不能完全函数决定另外一部分属性，那么 K 不是码。

比如有关系模式 R (Sno, Sname, Cno, Cname, Sdept, Sloc, Grade)，其中函数依赖集为 F= {  
Sno → Sname, Sno → Sdept, Sdept → Sloc，Sno → Sloc, Cno → Cname, (Sno, Cno) → Grade }

那么 R 中的码只能是 (Sno, Cno)，Sno 或 Cno 并不能完全函数决定除 Sno / Cno 之外的所有其他属性（其实就是不能决定 Grade )，所以单独的 Sno 与 Cno 并不能作为码。

所以可得到主属性：Sno, Cno  
非主属性：Sname, Cname, Sdept, Sloc, Grade

R 中存在非主属性 Cname 对于码 (Sno, Cno) 的部分函数依赖 (Cno → Cname) 。（还有很多别的例子就不一一列举了）。所以 R 不符合 2NF 的要求。

---

一范式就是属性不可分割。属性是什么？就是表中的字段。  
不可分割的意思就按字面理解就是最小单位，不能再分成更小单位了。  
这个字段只能是一个值，不能被拆分成多个字段，否则的话，它就是可分割的，就不符合一范式。  
不过能不能分割并没有绝对的答案，看需求，也就是看你的设计目标而定。  
举例：  
学生信息组成学生信息表，有姓名、年龄、性别、学号等信息组成。  
姓名不可拆分吧？所以可以作为该表的一个字段。  
但我要说这个表要在国外使用呢？人家姓和名要分开，都有特别的意义，所以姓名字段是可拆分的，分为姓字段和名字段。  
简单来说，一范式是关系数据库的基础，但字段是否真的不可拆分，根据你的设计目标而定。

二范式就是要有主键，要求其他字段都依赖于主键。  
为什么要有主键？没有主键就没有唯一性，没有唯一性在集合中就定位不到这行记录，所以要主键。  
其他字段为什么要依赖于主键？因为不依赖于主键，就找不到他们。更重要的是，其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的。  
如果有同学不理解依赖这个词，可以勉强用 “相关” 这个词代替，也就是说其他字段必须和它们的主键相关。因为不相关的东西不应该放在一行记录里。  
举例：  
学生信息组成学生表，姓名可以做主键么？  
不能！因为同名的话，就不唯一了，所以需要学号这样的唯一编码才行。  
那么其他字段依赖于主键是什么意思？  
就是 “张三” 同学的年龄和性别等字段，不能存储别人的年龄性别，必须是他自己的，因为张三的学号信息就决定了，这行记录归张三所有，不能给无关人员使用。

三范式就是要消除传递依赖，方便理解，可以看做是 “消除冗余”。  
消除冗余应该比较好理解一些，就是各种信息只在一个地方存储，不出现在多张表中。  
比如说大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：  
系编号，系主任，系简介，系架构。  
那么再回到学生信息表，张三同学的年龄、性别、学号都有了，我能不能把他的系编号，系主任、系简介也一起存着？  
如果你问三范式，当然不行，因为三范式不同意。  
因为系编号，系主任、系简介已经存在系别管理表中，你再存入学生信息表，就是冗余了。  
三范式中说的传递依赖，就出现了。  
这个时候学生信息表中，系主任信息是不是依赖于系编号了？而这个表的主键可是学号啊！  
所以按照三范式，处理这个问题的时候，学生表就只能增加一个系编号字段。  
这样既能根据系编号找到系别信息，又避免了冗余存储的问题。

---

1NF： 字段是最小的的单元不可再分  
2NF：满足 1NF, 表中的字段必须完全依赖于全部候选码而非部分候选码 (一般我们都会做到)  
3NF：满足 2NF, 非候选码外的所有字段必须互不依赖  
4NF：满足 3NF, 消除表中的多值依赖

---

1. 先要知道几个概念：  
码：一个表中，可以唯一决定一个元组的属性 “集合”。而主键则是可以唯一决定元组的‘某个属性’。  
例如：在成绩表中（学号，课程号）合起来叫一个码，而分开看学号是主键，课程号也是主键。  
非主属性：不属于码的属性。  
主属性：属于码的属性。  
候选键：指每个都不一样的、非空的那几个属性，有着潜在的主键意义。  
比如一个表中的课程号学号，系别号等等。。  
2. 通俗的讲范式：  
1）第一范式：属性不可拆分。  
如：地址这个属性是可拆分成城市地区等等，不可以把地址作为一个属性  
解决方案：属性拆分开来，将一个地址属性改成多个属性，按照城市地区.. 设置多个属性。  
2）第二范式：每个表中的非主属性完全依赖于码。  
特殊情况：若码只有一个属性，则必满足第二范式。  
如：（学号，课程号）这个表中的码被 “学生名字” 部分函数依赖。即包含有学号→学生名字这种依赖关系。不符合 2NF  
解决方案：将部分函数依赖的部分码和依赖这些码的属性拿出来单独成表，在原表中用外键代替以前的多个属性。  
个人理解：将部分单独拿出来，用一个外键在原表中代替，可以大大减少原表中的属性条数。  
3）第三范式：消除非主属性之间的依赖关系，只保留非主属性与码的依赖关系。  
（消除传递函数依赖的另一说法，本质是一样的）  
如：学号，课程号，系别，系主任。系别和系主任是非主属性，学号和课程号是主属性。但是系别和系主任这两个非主属性之间有函数依赖关系：系别→系主任。必造成传函依赖：学号→系别→系主任。不符合 3NF  
解决方案：将这个非主属性与其依赖的码都拿出来单独建表，并设置被依赖的属性为主键，在原表中则用外键表示。  
个人理解：将相互内在关联的非主属性用一个外键在原表中表示，可以大大减少数据冗余。  
4）BC 范式：每个表中只有一个候选键。  
如：学号，学生名字，学生 QQ。我们设置学号作主键，但是学生 QQ、学号这两个都是候选键，一张表中有多个候选键，不符合 BC 范式。  
解决方案：保留一个候选键作为主键，拿出其他的候选键单独成表，将原表中的主键放入该表中。在原表中不显示这个拿出来的候选键，从而 保证每个表中只有 1 个候选键。  
个人理解：主键越少越好。一个表中的候选键越少越好。  
但是这个 BC 范式有些苛刻了，很多情况比如成绩单表 (学生 课程 成绩) ，学生、课程为候选键，我们这样直接建表也是可以的。  

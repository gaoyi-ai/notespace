# Havel

(1)**对序列从大到小进行排序**
(2)**设最大的度数为t,把最大的度数置0,然后把最大度数后(不包括自己)的t个度数分别减1**
(就是把度数最大的点与后几个点进行连接)
(3) 
    - 如果序列中出现了负数,证明无法构成
        - 如果序列全部变为0,证明能构成,跳出循环
        - 前两点不出现，就跳回第一步

假设一个度序列（已经是非递增顺序排序）3,3,3,3,2
1.由于最大的是3，则从第2个开始，后面3个的值都要减去1，同时第1个值置0，即得0,2,2,2,2
2.重新排序后为2,2,2,2,0。最大的为2，则从第2个开始，后面2个的值都要减去1，同时第1个值置0，即0,1,1,2,0
3.重新排序后为2,1,1,0,0。最大的为2，则从2个开始，后面的2个值都要减去1，同时第1个值置0，即0,0,0,0,0，全部的值已经为0，即可以成图

**握手定理：对于每个图G=(V,E),均有∑d(v)(v属于V)=2*e(G).    e(G)为图的边数**
**推论1：任何图中,奇点的个数为偶数.**
**推论2：非负整数序列(d1,d2,...,dp)是某个图的度序列,则所有度之和∑(di)(1<=i<=n)是偶数.**


```python
def havel(seq):
    seq = sorted(seq,reverse=True) # 生成降序度序列
    if seq[0] == 0: # 递归终止条件：当排好序后，第一个度数为0，则一定全为0那么则可以在生成一个图
        return True
    i = 1
    while i <= seq[0]: # 从第二个开始，向后第一个度数值的每个节点度数减一
        seq[i] -= 1
        if seq[i] < 0: # 如果出现负数，则不成图
            return False
        i += 1
    seq[0] = 0 # 减完之后置0
    if not havel(seq):
        return False
    return True


sample = [3,3,3,3,2]
havel(sample) # True
```

---
title: HM Code
categories:
- Error Correct Code
tags:
- HMCode
date: 2019/8/1 20:00:12
updated: 2020/12/10 12:00:12
---

# Error Correct Code

纠错的基本原则就是在所有可能的消息所组成的巨大空间中，只有一些子集才算得上是有效信息。比如，当一条正确的信息被改后，接收方需要把错误信息纠正回最接近的有效信息。

![image-20201114123547790](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/image-20201114123547790.png)

## Parity Check

Change anywhere --> One bit of information

把信息中任何一处改变都反映在一个比特位上，注意，如果信息中任何一位翻转了，从0到1或者从1到0，到会导致1的数量从偶数变为奇数

# Hamming Code

![image-20201114124817316](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/image-20201114124817316.png)

> 为什么我们的奇偶性比特位正好落在了2的次方上，比如 1，2，4，8？

这些位置标签的二进制恰好只有一位是1，意昧着每一位奇偶性比特位正好落在了一个且仅有一个的奇偶性检验组里面

![image-20201114132933529](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/image-20201114132933529.png)

> 异或就是两个比特位的奇偶性 

![image-20201114134829950](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/image-20201114134829950.png)

去思考汉明码算法中奇偶性检验的方式，因为所有的计算都压缩成了一个操作。虽然第一眼看去非常不同，具体来说，把16个位置写成二进制就像我们之前所做的，接着把所有信息数位上为1的区域高亮，然后把这些位置的二进制标签放在一列，一起取"异或”

![image-20201114135118721](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/image-20201114135118721.png)

![image-20201114135150112](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/image-20201114135150112.png)

最右一列在计算所有末位为1的位置，但是我们已经把计算局限于高亮的这些位置，所有我们实际计算的是，**有多少高亮的位置属于第一组奇偶性组**

发送方负责切换奇偶性比特位，使得所得到的和为0000，现在我们有了这样一个漂亮的思路，就可以去思考，为什么最后我们在底下得到的结果可以直接告诉我们错误的位置？假设这个方格里的一些比特位从0变成了1，这意味着那个比特位的位置标签，会被加入进我们的异或操作里，所以最后加和的结果就从0变成了新加入进来的值。

```python
def hamming_syndrome(bits):
    return reduce(
        # reduce by xor
        lambda x, y: x ^ y,
        # all indices if active bits
        [i for (i, b) in enumerate(bits) if b]
    )
```

![image-20201114140307989](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/image-20201114140307989.png)

并且实际中错误往往会突发在一起,这就会毁掉整个块,所以一个常见的处理思路就是,在数据传输或储存之前,像这样把一连串的错误交错打散到许多个数据块中

![image-20201114140539202](https://gitee.com/gaoyi-ai/image-bed/raw/master/images/image-20201114140539202.png)



## 实现原理

海明校验码以奇偶校验为基础,但校验位不是一位,而是多位。它实质上就是一种多重奇偶校验码。它的实现原理是:在数据中加入多个校验位,并把数据的每个二进制位分配在多个奇偶校验组中。当某一位出错后,就会引起有关的几个校验位的值发生变化。通过校验,不但可以发现有无错误,而且还能指出出错位置,为自动纠错提供了依据。

## 组成规则

它由数据位和校验位组成,与奇偶校验的区别是:校验位较多,且穿插在数据位之间。

其组成规则有如下4点

- 校验位的位数r与数据位的位数k之间的关系:如只能检验与自动纠正一位错误，r与k应满足关系2^r^≥k+r+1

- 如要能检验与自动纠正一位错误,并发现两位出错,此时校验位的位数r与数据位的位数k的应满足下述关系2^r-1^≥k+r

- 检验位位置的确定:第i (i=1,2…r)位校验位占据第2^i-1^位的位置。即在海明码校验中,位号数(1,2,,…k+r)为2的权值的那些位用来放置校验位,余下的各位则放置发送的数据位。

- 为了能够检测并纠正一位错误,可以利用式(2-5)求得所需的校验位数为4位,分别记为P4P3P2P1。数据位和校验位位置分配为:
    海明码位号 H12 H11 H10 H9 H8 H7 H6 H5 H4 H3 H2 H1
    各位占位     D8   D7   D6  D5  P4 D4 D3 D2 P3 D1 P2 P1

- 为了能够检测并纠正一位错误,还可以发现是否有两位错,求得所需的校验位数为5位,分别记为P5P4P3P2P1

    P5只能放在第13位上,它已经是海明码的最高位了,其他4位满足P1的位号等于2的关系

- | 校验位Pi | Pi参与校验的海明码位号（k=8） |
    | -------- | ----------------------------- |
    | P1       | 3，5，7，9，11                |
    | P2       | 3，6，7，10，11               |
    | P3       | 5，6，7，12                   |
    | P4       | 9，10，11，12                 |

## 校验方法

如果发送端发送的有效数据为8位(k=8),校验位为5位(r=5),那么数据到达接收端后,应进行偶校验,求出相应的校验和S1~S5的表达式如下:
S1=P1\^D7\^D5\^D4\^D2\^D1
S2=P2\^D7\^D6\^D4\^D3\^D1
S3=P3\^D8\^D4\^D3\^D2
S4=P4\^D8\^D7\^D6\^D5
S5=P5\^P4\^P3\^P2\^P1\^D8\^D7\^D6\^D5\^D4\^D3\^D3\^D1

(1)通过S4 S3 S2 S1判别和纠正一位错
若(S4 S3 S2 S1)=0,则说明传送无错,即接收端接收的代码是正确的;否则,说明传送有错,且(S4 S3 S2 S1)的十进制数值就是出错的位置。

这是因为:若海明码第5位(D2)发生错误,则必然使S3、S1为1,即 S4 S3 S2 S1=0101,这个值正好指向第5位(D2)的位置,这样就完成查错。出错的位置明确,就可以通过相应的硬件电路进行纠错。

(2)通过S5 S4 S3 S2 S1判别两位错和纠正一位错
若(S4 S3 S2 S1)的十进制数值等于0,则说明传送无错
若(S4 S3 S2 S1)的十进制数值不等于0,而S5=0,则说明有两位发生了错误
若(S4 S3 S2 S1)的十进制数值不等于0,而S5=1,则说明发生了一位错误,且(S4S3S2S1)的十进制数值就是出错的位置
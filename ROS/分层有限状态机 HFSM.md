> [blog.csdn.net](https://blog.csdn.net/qq_35635374/article/details/121784539)

一、机器人 / 无人驾驶的行为决策的功能
====================

主要是依据来自上层（任务规划层）的任务类型（巡航、换道等任务），根据当前的交通场景和环境感知的信息的理解，来确定自身当前驾驶状态，在交通规则的约束和驾驶经验的指导下规划出合理的驾驶行为。  
![](https://img-blog.csdnimg.cn/2565983f0da543939e74931ccd66469b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55uS5a2Q5ZCbfg==,size_20,color_FFFFFF,t_70,g_se,x_16)

二、机器人 / 无人驾驶的行为决策系统设计准则–根据现实场景和要求抽象出来设计
=======================================

行为规划部分几乎直接关系到无人车的可靠性和安全性，要设计出完全符合人类驾驶员习惯和交通规则的行为规划系统在目前来看仍然是一大挑战，目前而言实现行为规划模块的方法很多，但是其设计理念大致可以总结为两点

1. 合理性

无人车驾驶的合理性建立在两个基础之上——交通法规和驾驶经验，其中交通法规的优先级又要高于驾驶经验，交通法规需要考虑的内容包括：靠右侧车道行驶，不能超速，换到超车时应提前开启转向灯，对于感知到的交通信号灯和交通标志，应按照其只是内容行驶，出现任何危险情况，应当能够果断地执行紧急制动等等。驾驶经验需要考虑的内容主要包括：尽量保持在原车道，不应随意变道；城市路段行驶时，不应随意加速，确保驾驶的平顺性；对于前车行驶缓慢而条件运行的情况应当果断超车等等。

2. 实时性

任何无人车系统中的行为规划都是实时的，行为规划应当能够处理复杂的动态交通场景，并且能够根据环境的变化快速的调整驾驶行为以避免危险的发生。  

三、机器人 / 无人驾驶的行为决策系统设计工具
=======================

1. 有限状态机 FSM

有限状态机就是一个非常简单的抽象反应系统，它之所以非常简单是因为它只对特定的外界输入产生数量有限的响应，在有限状态机中，我们只能构造有限数量的状态，外界的输入只能让状态机在有限的状态中从一个状态跳到另一个状态。

FSM 可进一步区分为确定型（Deterministic）和非确定型（Non-Deterministic）自动机。在确定型自动机中，每个状态对每个可能输入只有精确的一个转移。在非确定型自动机中，给定状态对给定可能输入可以没有或有多于一个转移。

2. 分层有限状态机 HFSM

### （1）分层有限状态机 HFSM 的概念

目前在无人车行为规划上并没有一个 “最佳解决方案”，目前普遍认可和采用的方法是分层有限状态机（Hierarchical Finite-State Machine ，HFSM），分层有限状态机也是早期 DARPA 挑战赛中被许多队伍采用的行为规划方法。而有限状态机是分层有限状态机的基础。

当状态很多的时候，有限状态机就有可能变得非常庞大，假设有限转态机有 N 中状态，那么其可能的状态转换就有 N×N 种，当状态的数量很大的时候，状态机的结构也会变得更加复杂，此外，有限状态机还存在如下几个问题：

**1）可维护性差**：当新增或者删除一个状态的时候，需要改变所有与之相关联的状态，所以对状态机的大幅度的修改很容易出错；  
**2）可扩展性差**：当 FSM 包含大量状态时，有向图可读性很差，不方便扩展；  
**3）复用性差**：几乎不可能在多个项目中使用相同的 FSM

这时候就可以使用分层状态机 (Hierarchical Finite-State Machine) 了

### （2）分层有限状态机 HFSM 的核心思想

**把那些同一类型的状态机做为一个状态机，然后再做一个大的状态机，来维护这些子状态机**，可以用 C++ 的基类和子类去理解，基类是一个状态机的模板，使用基类派生出多个小子类和一个管理子类，子类就是一个层次，子类之间下相互调用，同时子类又被管理子类维护  
![](https://img-blog.csdnimg.cn/d2d6a44d10a748d6b775b7f790eedacb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55uS5a2Q5ZCbfg==,size_19,color_FFFFFF,t_70,g_se,x_16)  
相比于 FSM，HFSM 新增了一个超级状态（Super-state）：本质上也就是将性质同一类型的一组状态何为一个集合（即上图中的大方框），超级状态之间也有转移逻辑。这也就意味着 HFSM 不需要为每一个状态和其他所有状态建立转移逻辑，由于状态被归类，类和类之间存在转移逻辑，那么类和类之间的状态转移可以通过继承这个转移逻辑来实现，这里的转换继承就像面向对象编程中通过多态性让子类继承超类一样。

### （2）分层有限状态机 HFSM 的在无人驾驶车的使用案例

“Junior” 是斯坦福大学在 2007 年参加 DARPA 城市挑战赛时的无人车，它是第二名完成该比赛的无人车，Junior 的行为规划系统就是通过分层有限状态机实现的，他们将顶层的驾驶行为分成了 13 个超级状态（也就是我们上图中的大方框），每个驾驶行为又对应一些子状态来完成这一行为。顶层行为由一个 FSM 管理，如下图所示：  
![](https://img-blog.csdnimg.cn/605f72971c3446158e68d0fcbcaba25a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55uS5a2Q5ZCbfg==,size_20,color_FFFFFF,t_70,g_se,x_16)  
我们简单的分析一下这个状态机：  
**LOCATE_VEHICLE**: 这是 Junior 的初始状态，即在无人车出发之前确定其在地图中的位置。

**FORWARD_DRIVE**: 这个超级状态实际上包含了直行，车道保持和障碍物规避，当不是在停车场（即无道路开放区域）时，这是状态机首选的状态。

**STOP_SIGN_WAIT**: 当无人车在停车标志处等待时，进入此状态。（停车标志是美国十字路口的常见标志）

**CROSS_INTERSECTION**：在这个状态下无人车处理十字路口通过这一场景，无人车会等待直到确认能够安全通过。

**UTURN_DRIVE**: 在 U 型掉头时调用的状态

**UTURN_STOP**: 在 U 型掉头前的停车状态

**CROSS_DIVIDER**: 跨过黄线行驶

**PARKING_NAVIGATE**：停车场内的普通驾驶模式

**TRAFFIC_JAM 和 ESCAPE**：处理交通阻塞时的两个状态

**BAD_RNDF**: 如果当前道路和预先做的路网图不同的时候，即进入该状态，在这个状态下，无人车会采用混合 A * 算法完成车辆的路径规划。

**MISSION_COMPLETE**: 当挑战赛（DARPA）结束，无人车进入该状态，即整个状态机的结束状态

在无人车正常行驶中这个状态机几乎处在普通驾驶模式（即 FORWARD_DRIVE 和 PARKING_NAVIGATE 这两个状态），系统通过 stuckness detectors（胶着检测器）来确定是否从普通驾驶状态转移至底层的其他状态，在完成了相应的动作以后行为模块又会回到原来的普通驾驶模式。这样的状态机能够让无人车处理一下复杂情况：

当前车道阻塞的时候，车辆会考虑驶入对面车道（即 CROSS_DIVIDER）, 如果对面车道也被阻塞了，则会启动 U 形转弯（UTURN_STOP/UTURN_DRIVE），此时内部 RNDF（Route Network Definition File，即全局路网图）也会相应修改，并执行 dynamic programming 以重新生成 RNDF 值函数。  
对于十字路口的交通阻塞问题，在等待时间结束以后，会调用混合 A _算法找出最近出口制动车辆离开阻塞区域。  
在单向通道阻塞的时候，如果规划失败也会调用混合 A_ 算法规划至下一个 GPS 路点。  
某些路点在循环多次以后仍然无法到达，那么跳过这个路点（这是为了防止车辆为了抵达规划中某个路点而进入死循环）  
如果无人车长时间没有取得任何的进展（指比赛的进展），车辆将会调用混合 A * 规划出通往附近的 GPS 航点的路径，这个规划是无视交通规则的。  
虽然 Junior 的策略有些是针对 DRAPA 挑战赛设计的（即为了尽可能赢得比赛），但是其设计的理念仍然具有参考价值。在实际的无人驾驶应用中，需要实现的状态机将更为复杂。虽然 HFSM 比传统的 FSM 更为模块化，但它仍然继承了 FSM 大多数缺点，例如有限的可重用性。
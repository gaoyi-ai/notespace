> [blog.csdn.net](https://blog.csdn.net/qq_35635374/article/details/120592768)

在项目和平时的学习中，我对**机器人 / 无人驾驶的决策规划模块**进行了划分，当然划分的方法有很多，我的划分方式仅供参考  
**（1）动态障碍物行为预测模块（Behavior prediction）**–结合感知和高精度地图信息，估计周围障碍物未来运动状态  
**（2）执行机构的轨迹规划模块（Trajectory_planning）**–执行机构如机器人载体上的机械臂、串行云台等的运动轨迹规划  
**（3）任务决策模块（Mission_planning）**–任务决策模块比较偏业务层了，处理机器人 / 无人驾驶的各种任务，主要分为三个方面：车底盘航线业务决策（交规、横向换道等等）、执行应用机构业务决策（机械臂、人机交互等等）、不同场景的导航方案切换决策（组合导航、融合导航）  
**（4）前端路径探索模块（path_finding）**–全局路径规划算法难度不算复杂，找到一条可通行的（必须满足）、考虑动力学的（尽可能满足）、可以是稀疏的路径 base_waypoints【由于其只考虑了环境几何信息，往往忽略了无人机本身的运动学与动力学模型。因此，其得到的轨迹往往显得比较 “突兀”，并不适合直接作为无人机的控制指令】  
**（5）后端轨迹处理模块（motion_planning）**–我主要归纳整理为三个方向：（1）对 base_waypoints 进行简单处理及生成方向、（2）对 base_waypoints 轨迹优化方向【一般是二次优化，这里用的较多的事优化方面的知识】、（3）进行对应功能的 replan 方向（replan 之前的预处理、进入 replan 的条件、停障 replan、避障 replan、纠偏 replan、换道 replan、自动泊车 replan、穿过狭窄道路 replan 等等），这部分内容使用的方法比较专  
**（6）路径跟踪模块（trajectory_following）**–这个模块就得针对机器人载体了，如无人驾驶使用得阿克曼模型可以采用几何的 pure pursuit 纯追踪算法，更好的可以用模型预测控制 MPC 方法，还有强化学习做的（效果怎样我就没验证过了）；当然也可能事麦克纳姆轮车、差速车 PID、还有无人机的三维轨迹跟踪等等  
**（7）碰撞检测模块**  
**（8）集群多机器人规划模块**

当然，这种划分方式是我权衡了原理和功能粗略划分的，在实际产品研发过程中，需要理解了各个算法的功能和定位的基础上融汇贯通，不能生搬硬套，如全段通过 hybrid A _探索出来的路径与 A_、RRT * 探索出来的路径更平滑，后端轨迹优化的任务就不用这么重了；又如，机器人 / 无人驾驶项目研发的需求业务还没发展到能响应很多功能阶段，任务决策使用简单的状态机（fsm）就可以对现有任务进行状态转移了

一、导航任务决策模块设计的介绍
===============

任务决策模块比较偏业务层了，研发中具体的根据机器人 / 无人驾驶业务层的需求进行设计，根据业务量的复杂程度，选用不同的任务决策工具和方法，实现既能满足现在的业务需求，又能又一定的拓展性

二、行为决策算法部署场景
==================

1. 自动驾驶航线业务决策【behavioral_planning】

（1）（交规）业务决策  
交通灯、斑马线、转弯、停障、避障、脱困、回充等等  
（2）横向换道移动决策  
（3）纵向换道移动决策  

2. 执行应用机构业务决策【function_planning】

（1）移动平台上的机械臂任务决策  
（2）人机交互作业  
这里可以把机器人理解成两个部分：底盘导航部分，底盘上的执行机构部分

3. 多种规划方案航线的切换决策

这种决策是为了支持机器人再不同场景的导航功能支撑，如室外与室内的定位方案切换、自由空间规划与约束空间的规划算法切换等等，我认为更偏向于机器人的算法和逻辑内部处理 

三、行为决策算法实现的工具
=============

1. 方式一：中断触发（ROS 的话题、服务、action 机制）

这种方法的实现更偏向于机器人控制系统（ROS），或者每家公司定制的嵌入式系统层面支持来实现的  
简单来理解就是如  
【微控制器方式】单片机 stm32、dsp、fpga 等微控制器的会提供外部中断、串口中断、定时器中断，就可以用系统级别的组件实现；再或者给单片机上一个实时系统 ucos 也好，freertos 也好，都有相关的系统工具
【处理器方式】无论是工控机、英伟达嵌入式设备还是个人 PC，裸奔 linux 可以用 boost 线程库处理决策，一般开发机器人都会装 ROS，也可以用 ROS 的的组件实现，通讯的服务机制也好，话题机制也好

优点：易于实现（demo 级别）  
缺点：任务状态转移是系统 SDK 决定的，状态转移过程不明确，决策任务少的时候还好，决策任务较多的时候，一个字–乱！

2. 方式二：编程语言 C/C++ 等的条件语法 if-else(switch)

如果任务状态较少的话，可以把状态分配给每个 case 执行，理解上 if-else 的语法就像一个二叉树，执行状态决策的时候，状态转移是比较困难的，状态也很难进行监视，决策的任务很简单，每个决策的进入和退出也很简单可以用用

优点：易于实现（demo 级别）  
缺点：决策任务复杂一点，状态很难管理

3. 方式三：有限状态机 FSM

状态机 Fsm 可以实现任意状态的切换和回溯  
自动驾驶车辆最开始的决策模型为有限状态机模型，车辆根据当前环境选择合适的驾驶行为，如停车、换道、超车、避让、缓慢行驶等模式，状态机模型通过构建有限的有向连通图来描述不同的驾驶状态以及状态之间的转移关系，从而根据驾驶状态的迁移反应式地生成驾驶动作。

有限状态机模型因为简单、易行，是无人驾驶领域目前最广泛的行为决策模型，但该类模型忽略了环境的动态性和不确定性，此外，当驾驶场景特征较多时，状态的划分和管理比较繁琐，多适用于简单场景下，很难胜任具有丰富结构化特征的城区道路环境下的行为决策任务。

4. 方式四：MDP

1、应用例子：解决从起点到终点存在多条可行的路径，根据环境的变化选择合适的路径

2、步骤介绍  
（1）在规划过程中的不确定因素【Uncertainties in Planning】  
（2）在不确定因素下进行规划【Planning with Uncertainties】  
（3）马可夫（MDP）决策过程【Markov Decision Process】  
（4）最大最小代价规划【Minimax Cost Planning】  
（5）最小期望代价规划【Expected Cost Planning】  
（6）值迭代和实时动态规划【Real Time Dynamic Programming】

5. 方式五：行为决策模型（POMDP）

决策 / 行为树模型和状态机模型类似，也是通过当前驾驶状态的属性值反应式地选择不同的驾驶动作，但不同的是该类模型将驾驶状态和控制逻辑固化到了树形结构中，通过自顶向下的 “轮询” 机制进行驾驶策略搜索。这类决策模型具备可视化的控制逻辑，并且控制节点可复用，但需要针对每个驾驶场景离线定义决策网路，当状态空间、行为空间较大时，控制逻辑将比较复杂。另外，该类模型同样无法考虑交通环境中存在的不确定性因素

6. 方式六：决策树 decision tree / 行为树 behaviar tree

7. 方式七：ROS 的任务级状态机 smach

smach 是 ROS 的一个功能包，再 ROS 可以用用，但是不在 ROS 上跑就没办法了 

8. 方式八：基于知识的推理决策

基于知识的推理决策模型由 “场景特征－驾驶动作” 的映射关系来模仿人类驾驶员的行为决策过程，该类模型将驾驶知识存储在知识库或者神经网络中，这里的驾驶知识主要表现为规则、案例或场景特征到驾驶动作的映射关系。进而，通过 “查询” 机制从知识库或者训练过的网络结构中推理出驾驶动作。

该类模型主要包括：基于规则的推理系统、基于案例的推理系统和基于神经网络的映射模型。

该类模型对先验驾驶知识、训练数据的依赖性较大，需要对驾驶知识进行精心整理、管理和更新，虽然基于神经网络的映射模型可以省去数据标注和知识整合的过程，但是仍然存在以下缺点：

其 “数据” 驱动机制使得其对训练数据的依赖性较大，训练数据需要足够充分；

将映射关系固化到网络结构中，其解释性较差；

存在 “黑箱” 问题，透明性差，对于实际系统中出现的问题可追溯性较差，很难发现问题的根本原因  

> https://blog.csdn.net/Travis_X/article/details/87791457